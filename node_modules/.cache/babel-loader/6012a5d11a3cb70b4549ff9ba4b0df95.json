{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar PatternMatcher = /*#__PURE__*/function () {\n  function PatternMatcher(pattern) {\n    _classCallCheck(this, PatternMatcher);\n\n    this.matchTree = new PatternParser().parse(pattern);\n  }\n\n  _createClass(PatternMatcher, [{\n    key: \"match\",\n    value: function match(string) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          allowOverflow = _ref.allowOverflow;\n\n      if (!string) {\n        throw new Error('String is required');\n      }\n\n      var result = _match(string.split(''), this.matchTree, true);\n\n      if (result && result.match) {\n        delete result.matchedChars;\n      }\n\n      if (result && result.overflow) {\n        if (!allowOverflow) {\n          return;\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return PatternMatcher;\n}();\n\nexport { PatternMatcher as default };\n\nfunction _match(characters, tree, last) {\n  if (typeof tree === 'string') {\n    if (last) {\n      // `tree` is always a single character.\n      if (characters.length > tree.length) {\n        return {\n          overflow: true\n        };\n      }\n    }\n\n    var characterString = characters.join('');\n\n    if (tree.indexOf(characterString) === 0) {\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n\n      /* istanbul ignore else */\n      if (characters.length === tree.length) {\n        return {\n          match: true,\n          matchedChars: characters\n        };\n      } // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n\n      /* istanbul ignore next */\n\n\n      return {\n        partialMatch: true // matchedChars: characters\n\n      };\n    }\n\n    if (characterString.indexOf(tree) === 0) {\n      return {\n        match: true,\n        matchedChars: characters.slice(0, tree.length)\n      };\n    }\n\n    return;\n  }\n\n  if (Array.isArray(tree)) {\n    var restCharacters = characters.slice();\n    var i = 0;\n\n    while (i < tree.length) {\n      var subtree = tree[i];\n\n      var result = _match(restCharacters, subtree, last && i === tree.length - 1);\n\n      if (!result) {\n        return;\n      } else if (result.overflow) {\n        return result;\n      } else if (result.match) {\n        // Continue with the next subtree with the rest of the characters.\n        restCharacters = restCharacters.slice(result.matchedChars.length);\n\n        if (restCharacters.length === 0) {\n          if (i === tree.length - 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          } else {\n            return {\n              partialMatch: true // matchedChars: characters\n\n            };\n          }\n        }\n      } else {\n        /* istanbul ignore else */\n        if (result.partialMatch) {\n          return {\n            partialMatch: true // matchedChars: characters\n\n          };\n        } else {\n          throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(result, null, 2)));\n        }\n      }\n\n      i++;\n    } // If `last` then overflow has already been checked\n    // by the last element of the `tree` array.\n\n    /* istanbul ignore if */\n\n\n    if (last) {\n      return {\n        overflow: true\n      };\n    }\n\n    return {\n      match: true,\n      matchedChars: characters.slice(0, characters.length - restCharacters.length)\n    };\n  }\n\n  switch (tree.op) {\n    case '|':\n      var partialMatch;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;) {\n        var branch = _step.value;\n\n        var _result = _match(characters, branch, last);\n\n        if (_result) {\n          if (_result.overflow) {\n            return _result;\n          } else if (_result.match) {\n            return {\n              match: true,\n              matchedChars: _result.matchedChars\n            };\n          } else {\n            /* istanbul ignore else */\n            if (_result.partialMatch) {\n              partialMatch = true;\n            } else {\n              throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(_result, null, 2)));\n            }\n          }\n        }\n      }\n\n      if (partialMatch) {\n        return {\n          partialMatch: true // matchedChars: ...\n\n        };\n      } // Not even a partial match.\n\n\n      return;\n\n    case '[]':\n      for (var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;) {\n        var _char = _step2.value;\n\n        if (characters[0] === _char) {\n          if (characters.length === 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          }\n\n          if (last) {\n            return {\n              overflow: true\n            };\n          }\n\n          return {\n            match: true,\n            matchedChars: [_char]\n          };\n        }\n      } // No character matches.\n\n\n      return;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(\"Unsupported instruction tree: \".concat(tree));\n  }\n}\n\nvar OPERATOR = new RegExp( // any of:\n'(' + // or operator\n'\\\\|' + // or\n'|' + // or group start\n'\\\\(\\\\?\\\\:' + // or\n'|' + // or group end\n'\\\\)' + // or\n'|' + // one-of set start\n'\\\\[' + // or\n'|' + // one-of set end\n'\\\\]' + ')');\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\n\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n\n      var _this$context$ = this.context[0],\n          branches = _this$context$.branches,\n          instructions = _this$context$.instructions;\n\n      if (branches) {\n        return [{\n          op: '|',\n          args: branches.concat([instructions])\n        }];\n      }\n      /* istanbul ignore if */\n\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n\n      var match = pattern.match(OPERATOR);\n\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n\n          var _this$getContext = this.getContext(),\n              branches = _this$getContext.branches;\n\n          branches.push(this.getContext().instructions);\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n\n          this.getContext().branches.push(this.getContext().instructions);\n          this.getContext().instructions = [];\n          break;\n\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n\n  return PatternParser;\n}();\n\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n\n    i++;\n  }\n\n  return values;\n}","map":{"version":3,"mappings":"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","names":["PatternMatcher","pattern","_classCallCheck","matchTree","PatternParser","parse","string","allowOverflow","Error","result","match","split","matchedChars","overflow","characters","tree","last","length","characterString","join","indexOf","partialMatch","slice","Array","isArray","restCharacters","i","subtree","JSON","stringify","op","args","branch","char","OPERATOR","RegExp","ILLEGAL_CHARACTER_REGEXP","context","or","instructions","parsePattern","branches","concat","push","pop","test","getContext","operator","before","index","rightPart","startContext","endContext","oneOfSet","parseOneOfSet","values","prevValue","charCodeAt","nextValue","value","String","fromCharCode"],"sources":["/Users/makhabatabdisattarova/Desktop/ZEON IT HUB/main-project/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternMatcher.js"],"sourcesContent":["export default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\nfunction match(characters, tree, last) {\r\n\tif (typeof tree === 'string') {\r\n\t\tif (last) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\toverflow: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nclass PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn [{\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([instructions])\r\n\t\t\t}]\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}"]},"metadata":{},"sourceType":"module"}